<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EasyTcp4.Encryption</name>
    </assembly>
    <members>
        <member name="M:EasyTcp4.Encryption.EncryptedProtocolUtil.UseSsl``1(``0,System.String,System.Boolean,System.Int32)">
            <summary>
            Use the ssl prefix length protocol
            </summary>
            <param name="client"></param>
            <param name="serverName">domain name of server, must be the same as in server certificate</param>
            <param name="acceptInvalidCertificates">determines whether the client can connect to servers that use an invalid certificate</param>
            <param name="maxMessageLength">maximimum amount of bytes for one message</param>
        </member>
        <member name="M:EasyTcp4.Encryption.EncryptedProtocolUtil.UseServerSsl``1(``0,System.Security.Cryptography.X509Certificates.X509Certificate,System.Int32)">
            <summary>
            Use the ssl prefix length protocol
            </summary>
            <param name="server"></param>
            <param name="certificate">server certificate</param>
            <param name="maxMessageLength">maximimum amount of bytes for one message</param>
        </member>
        <member name="M:EasyTcp4.Encryption.EncryptedProtocolUtil.UsePlainTcp``1(``0,System.String,System.Boolean,System.Int32)">
            <summary>
            Use the plain ssl protocol
            </summary>
            <param name="client"></param>
            <param name="serverName">domain name of server, must be the same as in server certificate</param>
            <param name="acceptInvalidCertificates">determines whether the client can connect to servers that use an invalid certificate</param>
            <param name="bufferSize">size of the receive buffer, maximum size of a message</param>
        </member>
        <member name="M:EasyTcp4.Encryption.EncryptedProtocolUtil.UseServerPlainTcp``1(``0,System.Security.Cryptography.X509Certificates.X509Certificate,System.Int32)">
            <summary>
            Use the plain ssl protocol
            </summary>
            <param name="server"></param>
            <param name="certificate">server certificate</param>
            <param name="bufferSize">size of the receive buffer, maximum size of a message</param>
        </member>
        <member name="T:EasyTcp4.Encryption.Ssl.PlainSslProtocol">
            <summary>
            Protocol that doesn't implements any framing
            Useful when communicating with an already existing tcp server/client
            </summary>
        </member>
        <member name="F:EasyTcp4.Encryption.Ssl.PlainSslProtocol.DefaultBufferSize">
            <summary>
            Default bufferSize when not specified
            </summary>
        </member>
        <member name="P:EasyTcp4.Encryption.Ssl.PlainSslProtocol.BufferSize">
            <summary>
            Size of the receive buffer 
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.PlainSslProtocol.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Int32)">
            <summary></summary>
            <param name="certificate">server certificate</param>
            <param name="bufferSize">size of the receive buffer, maximum size of a message</param>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.PlainSslProtocol.#ctor(System.String,System.Boolean,System.Int32)">
            <summary></summary>
            <param name="serverName">domain name of server, must be the same as in server certificate</param>
            <param name="acceptInvalidCertificates">determines whether the client can connect to servers that use an invalid certificate</param>
            <param name="bufferSize">size of the receive buffer, maximum size of a message</param>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.PlainSslProtocol.SendMessage(EasyTcp4.EasyTcpClient,System.Byte[][])">
            <summary>
            Send message to remote host
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.PlainSslProtocol.OnDataReceive(System.Byte[],System.Int32,EasyTcp4.EasyTcpClient)">
            <summary>
            Handle received data, this function should trigger the OnDataReceive event of the passed client
            </summary>
            <param name="data">received data</param>
            <param name="receivedBytes">amount of received bytes</param>
            <param name="client">client that received the data</param>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.PlainSslProtocol.Clone">
            <summary>
            Return new instance of protocol 
            </summary>
        </member>
        <member name="T:EasyTcp4.Encryption.Ssl.PrefixLengthSslProtocol">
            <summary>
            Protocol that determines the length of a message based on a small header
            Header is an int as byte[] with the length of the message.
            </summary>
        </member>
        <member name="P:EasyTcp4.Encryption.Ssl.PrefixLengthSslProtocol.BufferSize">
            <summary>
            Size of the receive buffer 
            </summary>
        </member>
        <member name="P:EasyTcp4.Encryption.Ssl.PrefixLengthSslProtocol.BufferOffset">
            <summary>
            Offset of the receive buffer, where to start saving the received data
            </summary>
        </member>
        <member name="P:EasyTcp4.Encryption.Ssl.PrefixLengthSslProtocol.BufferCount">
            <summary>
            The maximum amount of bytes to receive in the receive buffer
            </summary>
        </member>
        <member name="F:EasyTcp4.Encryption.Ssl.PrefixLengthSslProtocol.ReceivedHeader">
            <summary>
            Determines whether the header for the message is received 
            </summary>
        </member>
        <member name="F:EasyTcp4.Encryption.Ssl.PrefixLengthSslProtocol.MaxMessageLength">
            <summary>
            Maximimum amount of bytes for one message
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.PrefixLengthSslProtocol.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Int32)">
            <summary></summary>
            <param name="certificate">server certificate</param>
            <param name="maxMessageLength">maximimum amount of bytes for one message</param>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.PrefixLengthSslProtocol.#ctor(System.String,System.Boolean,System.Int32)">
            <summary></summary>
            <param name="serverName">domain name of server, must be the same as in server certificate</param>
            <param name="acceptInvalidCertificates">determines whether the client can connect to servers that use an invalid certificate</param>
            <param name="maxMessageLength">maximimum amount of bytes for one message</param>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.PrefixLengthSslProtocol.SendMessage(EasyTcp4.EasyTcpClient,System.Byte[][])">
            <summary>
            Send message to remote host
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.PrefixLengthSslProtocol.OnDataReceive(System.Byte[],System.Int32,EasyTcp4.EasyTcpClient)">
            <summary>
            Handle received data, this function should trigger the OnDataReceive event of the passed client
            </summary>
            <param name="data">received data</param>
            <param name="receivedBytes">amount of received bytes</param>
            <param name="client">client that received the data</param>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.PrefixLengthSslProtocol.Clone">
            <summary>
            Return new instance of protocol 
            </summary>
            <returns>new object</returns>
        </member>
        <member name="T:EasyTcp4.Encryption.Ssl.SslProtocol">
            <summary>
            Abstract implementation of the tcp/ssl protocol
            Base class of the other ssl protocols
            </summary>
        </member>
        <member name="F:EasyTcp4.Encryption.Ssl.SslProtocol.ReceiveBuffer">
            <summary>
            Buffer used to receive new data 
            </summary>
        </member>
        <member name="F:EasyTcp4.Encryption.Ssl.SslProtocol.AcceptArgs">
            <summary>
            AsyncEventArgs used to accept new connections (null for clients)
            </summary>
        </member>
        <member name="F:EasyTcp4.Encryption.Ssl.SslProtocol.IsListening">
            <summary>
            Determines whether client is listening for data
            </summary>
        </member>
        <member name="F:EasyTcp4.Encryption.Ssl.SslProtocol.SslStream">
            <summary>
            Encrypted networkstream used for receiving / sending data
            </summary>
        </member>
        <member name="F:EasyTcp4.Encryption.Ssl.SslProtocol.NetworkStream">
            <summary>
            Unencrypted networkstream
            </summary>
        </member>
        <member name="F:EasyTcp4.Encryption.Ssl.SslProtocol.Certificate">
            <summary>
            Certificate used by SslStream
            ignored if protocol is used by a client
            </summary>
        </member>
        <member name="F:EasyTcp4.Encryption.Ssl.SslProtocol.ServerName">
            <summary>
            ServerName used by SslStream.AuthenticateAsClient, must be the same as the servername in the server certificate
            ignored if protocol is used by a server
            </summary>
        </member>
        <member name="F:EasyTcp4.Encryption.Ssl.SslProtocol.AcceptInvalidCertificates">
            <summary>
            Determines whether the client can connect to servers that use an invalid certificate 
            ignored if protocol is used by a server
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary></summary>
            <param name="certificate">server certificate</param>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.#ctor(System.String,System.Boolean)">
            <summary></summary>
            <param name="serverName">domain name of server, must be the same as in server certificate</param>
            <param name="acceptInvalidCertificates">determines whether the client can connect to servers that use an invalid certificate</param>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.GetSocket(System.Net.Sockets.AddressFamily)">
            <summary>
            Get a new instance of a socket compatible with protocol 
            Used by the Connect and Start utils
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.GetStream(EasyTcp4.EasyTcpClient)">
            <summary>
            Get receiving/sending stream
            Stream will not be disposed after use, reuse same stream and dispose stream in .Dispose function of protocol
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.StartAcceptingClients(EasyTcp4.EasyTcpServer)">
            <summary>
            Start accepting new connections 
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.EnsureDataReceiverIsRunning(EasyTcp4.EasyTcpClient)">
            <summary>
            Start or continue listerning for incoming data
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.OnConnect(EasyTcp4.EasyTcpClient)">
            <summary>
            Method that is triggered when client connected to remote endpoint 
            Authenticate as client and start accepting new data
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.OnConnectServer(EasyTcp4.EasyTcpClient)">
            <summary>
            Method that is triggered when server acceptes a new client
            Authenticate as server and start accepting new data
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.Dispose">
            <summary>
            Dispose protocol, automatically called by client.Dispose and server.Dispose 
            </summary>
        </member>
        <member name="P:EasyTcp4.Encryption.Ssl.SslProtocol.BufferSize">
            <summary>
            Size of the receive buffer 
            </summary>
        </member>
        <member name="P:EasyTcp4.Encryption.Ssl.SslProtocol.BufferOffset">
            <summary>
            Offset of the receive buffer, where to start saving the received data
            Default is offset is 0
            </summary>
        </member>
        <member name="P:EasyTcp4.Encryption.Ssl.SslProtocol.BufferCount">
            <summary>
            The maximum amount of bytes to receive in the receive buffer
            Default count is the bufferSize - BufferOffset
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.SendMessage(EasyTcp4.EasyTcpClient,System.Byte[][])">
            <summary>
            Send message to remote host
            This method should trigger the OnDataSend event
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.OnDataReceive(System.Byte[],System.Int32,EasyTcp4.EasyTcpClient)">
            <summary>
            Handle received data, this function should trigger the OnDataReceive event of the passed client
            </summary>
            <param name="data">received data</param>
            <param name="receivedBytes">amount of received bytes</param>
            <param name="client">client that received the data</param>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.Clone">
            <summary>
            Return new instance of protocol
            Used by the server to create copies of protocol for all connected clients.
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.ValidateServerCertificate(System.Object,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            Determines whether a certificate is valid
            this function is a callback used by the OnConnect function
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.HandleDisconnect(EasyTcp4.EasyTcpClient)">
            <summary>
            Process a disconnected client 
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.OnConnectCallback(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Callback method that accepts new tcp connections
            </summary>
        </member>
        <member name="M:EasyTcp4.Encryption.Ssl.SslProtocol.OnReceiveCallback(System.IAsyncResult)">
            <summary>
            Callback method that handles receiving data and disconnects
            </summary>
        </member>
    </members>
</doc>
